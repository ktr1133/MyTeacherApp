/**
 * ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
 * 
 * ã‚¢ãƒ—ãƒªå…¨ä½“ã§ã‚¢ãƒã‚¿ãƒ¼çŠ¶æ…‹ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã®Context APIå®Ÿè£…
 * ç”»é¢é·ç§»æ™‚ã‚‚ã‚¢ãƒã‚¿ãƒ¼è¡¨ç¤ºçŠ¶æ…‹ã‚’ç¶­æŒ
 */
import React, { createContext, useContext, useState, useCallback, useRef, useEffect } from 'react';
import {
  AvatarEventType,
  AvatarDisplayData,
  AvatarWidgetConfig,
  AvatarState,
} from '../types/avatar.types';
import avatarService from '../services/avatar.service';

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
 */
const DEFAULT_CONFIG: Required<AvatarWidgetConfig> = {
  autoHideDelay: 20000, // 20ç§’
  position: 'center',
  enableAnimation: true,
};

/**
 * ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å‹å®šç¾©
 */
interface AvatarContextType {
  // çŠ¶æ…‹
  isVisible: boolean;
  currentData: AvatarDisplayData | null;
  isLoading: boolean;

  // åˆ¶å¾¡é–¢æ•°
  dispatchAvatarEvent: (eventType: AvatarEventType) => Promise<void>;
  showAvatarDirect: (
    comment: string,
    imageUrl: string,
    animation: string,
    eventType?: AvatarEventType
  ) => void;
  hideAvatar: () => void;
}

/**
 * ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
 */
const AvatarContext = createContext<AvatarContextType | undefined>(undefined);

/**
 * ã‚¢ãƒã‚¿ãƒ¼ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
 */
interface AvatarProviderProps {
  children: React.ReactNode;
  config?: AvatarWidgetConfig;
}

/**
 * ã‚¢ãƒã‚¿ãƒ¼ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
 * 
 * ã‚¢ãƒ—ãƒªã®ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã§ä½¿ç”¨ã—ã€å…¨ç”»é¢ã§ã‚¢ãƒã‚¿ãƒ¼çŠ¶æ…‹ã‚’å…±æœ‰
 */
export const AvatarProvider: React.FC<AvatarProviderProps> = ({ children, config = {} }) => {
  const mergedConfig = { ...DEFAULT_CONFIG, ...config };

  // çŠ¶æ…‹ç®¡ç†
  const [state, setState] = useState<AvatarState>({
    isVisible: false,
    currentData: null,
    isLoading: false,
  });

  // è‡ªå‹•éè¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼å‚ç…§
  const autoHideTimerRef = useRef<NodeJS.Timeout | null>(null);

  /**
   * ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
   */
  const clearAutoHideTimer = useCallback(() => {
    if (autoHideTimerRef.current) {
      clearTimeout(autoHideTimerRef.current);
      autoHideTimerRef.current = null;
    }
  }, []);

  /**
   * è‡ªå‹•éè¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
   */
  const setAutoHideTimer = useCallback(() => {
    clearAutoHideTimer();
    autoHideTimerRef.current = setTimeout(() => {
      hideAvatar();
    }, mergedConfig.autoHideDelay);
  }, [mergedConfig.autoHideDelay, clearAutoHideTimer]);

  /**
   * ã‚¢ãƒã‚¿ãƒ¼ã‚’è¡¨ç¤º
   * 
   * @param data - è¡¨ç¤ºãƒ‡ãƒ¼ã‚¿
   */
  const showAvatar = useCallback(
    (data: AvatarDisplayData) => {
      console.log('ğŸ­ [AvatarContext] showAvatar called with data:', data);
      setState({
        isVisible: true,
        currentData: data,
        isLoading: false,
      });
      console.log('ğŸ­ [AvatarContext] State updated: isVisible=true');

      // è‡ªå‹•éè¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
      setAutoHideTimer();
      console.log('ğŸ­ [AvatarContext] Auto-hide timer set');
    },
    [setAutoHideTimer]
  );

  /**
   * ã‚¢ãƒã‚¿ãƒ¼ã‚’éè¡¨ç¤º
   */
  const hideAvatar = useCallback(() => {
    console.log('ğŸ­ [AvatarContext] hideAvatar called');
    setState((prev) => ({
      ...prev,
      isVisible: false,
    }));
    clearAutoHideTimer();
  }, [clearAutoHideTimer]);

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ã§ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—ãƒ»è¡¨ç¤º
   * 
   * @param eventType - ã‚¢ãƒã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆç¨®åˆ¥
   */
  const dispatchAvatarEvent = useCallback(
    async (eventType: AvatarEventType) => {
      console.log('ğŸ­ [AvatarContext] dispatchAvatarEvent called:', { eventType });
      try {
        setState((prev) => ({ ...prev, isLoading: true }));
        console.log('ğŸ­ [AvatarContext] State set to loading');

        const response = await avatarService.getCommentForEvent(eventType);
        console.log('ğŸ­ [AvatarContext] API response received:', response);

        const displayData: AvatarDisplayData = {
          comment: response.comment,
          imageUrl: response.imageUrl,
          animation: response.animation,
          eventType,
          timestamp: Date.now(),
        };
        console.log('ğŸ­ [AvatarContext] Display data prepared:', displayData);

        showAvatar(displayData);
        console.log('ğŸ­ [AvatarContext] showAvatar called');
      } catch (error) {
        console.error('ğŸ­ [AvatarContext] Failed to fetch avatar comment:', error);
        setState((prev) => ({ ...prev, isLoading: false }));
      }
    },
    [showAvatar]
  );

  /**
   * ã‚¢ãƒã‚¿ãƒ¼ã‚’ç›´æ¥è¡¨ç¤ºï¼ˆAPIã‚³ãƒ¼ãƒ«ãªã—ï¼‰
   * 
   * @param comment - ã‚³ãƒ¡ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆ
   * @param imageUrl - ç”»åƒURL
   * @param animation - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç¨®åˆ¥
   * @param eventType - ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
   */
  const showAvatarDirect = useCallback(
    (
      comment: string,
      imageUrl: string,
      animation: string,
      eventType: AvatarEventType = 'task_created'
    ) => {
      console.log('ğŸ­ [AvatarContext] showAvatarDirect called:', {
        comment,
        imageUrl,
        animation,
        eventType,
      });
      const displayData: AvatarDisplayData = {
        comment,
        imageUrl,
        animation: animation as any,
        eventType,
        timestamp: Date.now(),
      };

      showAvatar(displayData);
    },
    [showAvatar]
  );

  /**
   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ï¼‰
   */
  useEffect(() => {
    return () => {
      clearAutoHideTimer();
    };
  }, [clearAutoHideTimer]);

  const value: AvatarContextType = {
    // çŠ¶æ…‹
    isVisible: state.isVisible,
    currentData: state.currentData,
    isLoading: state.isLoading,

    // åˆ¶å¾¡é–¢æ•°
    dispatchAvatarEvent,
    showAvatarDirect,
    hideAvatar,
  };

  return <AvatarContext.Provider value={value}>{children}</AvatarContext.Provider>;
};

/**
 * ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ•ãƒƒã‚¯
 * 
 * @returns ã‚¢ãƒã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
 * @throws AvatarProviderã§ãƒ©ãƒƒãƒ—ã•ã‚Œã¦ã„ãªã„å ´åˆ
 */
export const useAvatarContext = (): AvatarContextType => {
  const context = useContext(AvatarContext);
  if (!context) {
    throw new Error('useAvatarContext must be used within AvatarProvider');
  }
  return context;
};
